version: "3.9"

networks:
  default:
    name: instill
    external: false

secrets:
  ca:
    file: ./secrets/certs/ca/ca.crt
  api-gateway.cert:
    file: ./secrets/certs/api-gateway/api-gateway.crt
  api-gateway.key:
    file: ./secrets/certs/api-gateway/api-gateway.key
  influxdb.cert:
    file: ./secrets/certs/influxdb/influxdb.crt
  influxdb.key:
    file: ./secrets/certs/influxdb/influxdb.key
  mgmt-backend.cert:
    file: ./secrets/certs/mgmt-backend/mgmt-backend.crt
  mgmt-backend.key:
    file: ./secrets/certs/mgmt-backend/mgmt-backend.key
  model-backend.cert:
    file: ./secrets/certs/model-backend/model-backend.crt
  model-backend.key:
    file: ./secrets/certs/model-backend/model-backend.key
  pipeline-backend.cert:
    file: ./secrets/certs/pipeline-backend/pipeline-backend.crt
  pipeline-backend.key:
    file: ./secrets/certs/pipeline-backend/pipeline-backend.key
  hydra.cert:
    file: ./secrets/certs/hydra/hydra.crt
  hydra.key:
    file: ./secrets/certs/hydra/hydra.key
  kratos.cert:
    file: ./secrets/certs/kratos/kratos.crt
  kratos.key:
    file: ./secrets/certs/kratos/kratos.key

services:
  api_gateway:
    container_name: api-gateway
    image: api-gateway:dev
    restart: unless-stopped
    build:
      context: .
      dockerfile: ./api-gateway/Dockerfile
      target: dev
      args:
        BASE_KRAKEND_VERSION: ${BASE_KRAKEND_VERSION}
    secrets:
      - source: ca
        target: /etc/ssl/certs/ca.crt
      - source: api-gateway.cert
        target: /api-gateway/ssl/tls.crt
      - source: api-gateway.key
        target: /api-gateway/ssl/tls.key
    ports:
      - ${API_GATEWAY_HTTPS_PORT}:${API_GATEWAY_HTTPS_PORT} # krakend
      - ${API_GATEWAY_STATS_PORT}:${API_GATEWAY_STATS_PORT} # stats
      - ${API_GATEWAY_METRICS_PORT}:${API_GATEWAY_METRICS_PORT} # prometheus
    command: run --debug --config /api-gateway/config/krakend.json

  influxdb:
    container_name: influxdb
    image: influxdb:1.8
    restart: unless-stopped
    environment:
      - INFLUXDB_DB=krakend
      - INFLUXDB_USER=grafana
      - INFLUXDB_USER_PASSWORD=grafana
      - INFLUXDB_HTTP_HTTPS_ENABLED=true
      - INFLUXDB_HTTP_HTTPS_CERTIFICATE=/etc/influxdb/ssl/influxdb.cert
      - INFLUXDB_HTTP_HTTPS_PRIVATE_KEY=/etc/influxdb/ssl/influxdb.key
      - INFLUXDB_SUBSCRIBER_CA_CERTS=/etc/ssl/certs/ca.crt
    secrets:
      - source: ca
        target: /etc/ssl/certs/ca.crt
      - source: influxdb.cert
        target: /etc/influxdb/ssl/influxdb.cert
      - source: influxdb.key
        target: /etc/influxdb/ssl/influxdb.key
    ports:
      - ${INFLUXDB_HTTPS_PORT}:${INFLUXDB_HTTPS_PORT}

  mgmt_backend_migrate:
    container_name: ${MGMT_BACKEND_HOST}-migrate
    image: instill/mgmt-backend:${MGMT_BACKEND_VERSION}
    restart: on-failure
    environment:
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
    entrypoint: ./mgmt-backend-migrate
    depends_on:
      pg_sql:
        condition: service_healthy

  mgmt_backend_init:
    container_name: ${MGMT_BACKEND_HOST}-init
    image: instill/mgmt-backend:${MGMT_BACKEND_VERSION}
    restart: on-failure
    environment:
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
    entrypoint: ./mgmt-backend-init
    depends_on:
      - mgmt_backend_migrate

  mgmt_backend:
    container_name: ${MGMT_BACKEND_HOST}
    image: instill/mgmt-backend:${MGMT_BACKEND_VERSION}
    restart: unless-stopped
    environment:
      CFG_SERVER_PORT: 8084
      CFG_SERVER_DEBUG: "true"
      CFG_SERVER_DISABLEUSAGE: ${DISABLEUSAGE}
      CFG_SERVER_EDITION: local-ce:${MGMT_BACKEND_VERSION}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_SERVER_CORSORIGINS: http://${DOMAIN:-localhost}:${CONSOLE_PORT}
    ports:
      - ${MGMT_BACKEND_HTTPS_PORT}:8084
    entrypoint: ./mgmt-backend
    depends_on:
      - mgmt_backend_init

  model_backend_migrate:
    container_name: ${MODEL_BACKEND_HOST}-migrate
    image: instill/model-backend:${MODEL_BACKEND_VERSION}
    restart: on-failure
    environment:
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
    entrypoint: ./model-backend-migrate
    depends_on:
      pg_sql:
        condition: service_healthy

  model_backend_init:
    container_name: ${MODEL_BACKEND_HOST}-init
    image: instill/model-backend:${MODEL_BACKEND_VERSION}
    restart: on-failure
    environment:
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
    entrypoint: ./model-backend-init
    depends_on:
      - model_backend_migrate

  model_backend:
    container_name: ${MODEL_BACKEND_HOST}
    image: instill/model-backend:${MODEL_BACKEND_VERSION}
    restart: unless-stopped
    environment:
      CFG_SERVER_PORT: 8083
      CFG_SERVER_DEBUG: "true"
      CFG_SERVER_DISABLEUSAGE: ${DISABLEUSAGE}
      CFG_SERVER_EDITION: local-ce:${MODEL_BACKEND_VERSION}
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
      CFG_MGMTBACKEND_HOST: ${MGMT_BACKEND_HOST}
      CFG_MGMTBACKEND_PORT: ${MGMT_BACKEND_HTTPS_PORT}
      CFG_PIPELINEBACKEND_HOST: ${PIPELINE_BACKEND_HOST}
      CFG_PIPELINEBACKEND_PORT: ${PIPELINE_BACKEND_HTTPS_PORT}
      CFG_TRITONSERVER_GRPCURI: ${TRITON_SERVER_HOST}:${TRITON_SERVER_PORT}
      CFG_TEMPORAL_CLIENTOPTIONS_HOSTPORT: ${TEMPORAL_HOST}:${TEMPORAL_PORT}
      CFG_CACHE_REDIS_REDISOPTIONS_ADDR: ${REDIS_HOST}:${REDIS_PORT}
      CFG_TRITONSERVER_MODELSTORE: /model-repository
      CFG_SERVER_CORSORIGINS: http://${DOMAIN:-localhost}:${CONSOLE_PORT}
      CFG_SERVER_HTTPS_CERT: /model-backend/ssl/tls.crt
      CFG_SERVER_HTTPS_KEY: /model-backend/ssl/tls.key
    ports:
      - ${MODEL_BACKEND_HTTPS_PORT}:8083
    volumes:
      - model_repository:/model-repository
    entrypoint: ./model-backend
    depends_on:
      triton_server:
        condition: service_healthy
      model_backend_init:
        condition: service_completed_successfully
    secrets:
      - source: ca
        target: /etc/ssl/certs/ca.crt
      - source: model-backend.cert
        target: /model-backend/ssl/tls.crt
      - source: model-backend.key
        target: /model-backend/ssl/tls.key

  pipeline_backend_migrate:
    container_name: ${PIPELINE_BACKEND_HOST}-migrate
    image: instill/pipeline-backend:${PIPELINE_BACKEND_VERSION}
    restart: on-failure
    environment:
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
    entrypoint: ./pipeline-backend-migrate
    depends_on:
      pg_sql:
        condition: service_healthy

  pipeline_backend:
    container_name: ${PIPELINE_BACKEND_HOST}
    image: instill/pipeline-backend:${PIPELINE_BACKEND_VERSION}
    restart: unless-stopped
    environment:
      CFG_SERVER_PORT: 8081
      CFG_SERVER_DEBUG: "true"
      CFG_SERVER_DISABLEUSAGE: ${DISABLEUSAGE}
      CFG_SERVER_EDITION: local-ce:${PIPELINE_BACKEND_VERSION}
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
      CFG_MGMTBACKEND_HOST: ${MGMT_BACKEND_HOST}
      CFG_MGMTBACKEND_PORT: ${MGMT_BACKEND_HTTPS_PORT}
      CFG_CONNECTORBACKEND_HOST: ${CONNECTOR_BACKEND_HOST}
      CFG_CONNECTORBACKEND_PORT: ${CONNECTOR_BACKEND_HTTPS_PORT}
      CFG_MODELBACKEND_HOST: ${MODEL_BACKEND_HOST}
      CFG_MODELBACKEND_PORT: ${MODEL_BACKEND_HTTPS_PORT}
      CFG_TEMPORAL_CLIENTOPTIONS_HOSTPORT: ${TEMPORAL_HOST}:${TEMPORAL_PORT}
      CFG_CACHE_REDIS_REDISOPTIONS_ADDR: ${REDIS_HOST}:${REDIS_PORT}
      CFG_SERVER_CORSORIGINS: http://${DOMAIN:-localhost}:${CONSOLE_PORT}
    ports:
      - ${PIPELINE_BACKEND_HTTPS_PORT}:8081
    entrypoint: ./pipeline-backend
    depends_on:
      - pipeline_backend_migrate
      - temporal
      - redis

  connector_backend_migrate:
    container_name: ${CONNECTOR_BACKEND_HOST}-migrate
    image: instill/connector-backend:${CONNECTOR_BACKEND_VERSION}
    restart: on-failure
    environment:
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
    entrypoint: ./connector-backend-migrate
    depends_on:
      pg_sql:
        condition: service_healthy

  connector_backend_init:
    container_name: ${CONNECTOR_BACKEND_HOST}-init
    image: instill/connector-backend:${CONNECTOR_BACKEND_VERSION}
    restart: on-failure
    environment:
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
    entrypoint: ./connector-backend-init
    depends_on:
      - connector_backend_migrate

  connector_backend_worker:
    container_name: ${CONNECTOR_BACKEND_HOST}-worker
    image: instill/connector-backend:${CONNECTOR_BACKEND_VERSION}
    restart: unless-stopped
    environment:
      CFG_WORKER_MOUNTSOURCE_VDP: vdp
      CFG_WORKER_MOUNTSOURCE_AIRBYTE: airbyte
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
      CFG_TEMPORAL_CLIENTOPTIONS_HOSTPORT: ${TEMPORAL_HOST}:${TEMPORAL_PORT}
    volumes:
      - vdp:/vdp
      - airbyte:/airbyte
      - /var/run/docker.sock:/var/run/docker.sock
    entrypoint: ./connector-backend-worker
    depends_on:
      connector_backend_init:
        condition: service_completed_successfully
      temporal:
        condition: service_healthy

  connector_backend:
    container_name: ${CONNECTOR_BACKEND_HOST}
    image: instill/connector-backend:${CONNECTOR_BACKEND_VERSION}
    restart: unless-stopped
    environment:
      CFG_SERVER_PORT: 8082
      CFG_SERVER_DEBUG: "true"
      CFG_SERVER_DISABLEUSAGE: ${DISABLEUSAGE}
      CFG_SERVER_EDITION: local-ce:latest
      CFG_DATABASE_HOST: ${PG_SQL_HOST}
      CFG_DATABASE_PORT: ${PG_SQL_PORT}
      CFG_DATABASE_USERNAME: ${PG_SQL_USERNAME}
      CFG_DATABASE_PASSWORD: ${PG_SQL_PASSWORD}
      CFG_MGMTBACKEND_HOST: ${MGMT_BACKEND_HOST}
      CFG_MGMTBACKEND_PORT: ${MGMT_BACKEND_HTTPS_PORT}
      CFG_PIPELINEBACKEND_HOST: ${PIPELINE_BACKEND_HOST}
      CFG_PIPELINEBACKEND_PORT: ${PIPELINE_BACKEND_HTTPS_PORT}
      CFG_TEMPORAL_CLIENTOPTIONS_HOSTPORT: ${TEMPORAL_HOST}:${TEMPORAL_PORT}
      CFG_SERVER_CORSORIGINS: http://${DOMAIN:-localhost}:${CONSOLE_PORT}
    ports:
      - ${CONNECTOR_BACKEND_HTTPS_PORT}:8082
    entrypoint: ./connector-backend
    depends_on:
      - connector_backend_worker

  hydra_migrate:
    container_name: hydra-migrate
    image: oryd/hydra:${HYDRA_VERSION}-sqlite
    environment:
      - DSN=sqlite:///var/lib/sqlite/db.sqlite?_fk=true&mode=rwc
    volumes:
      - type: volume
        source: hydra_sqlite
        target: /var/lib/sqlite
        read_only: false
    command: migrate sql -e --yes
    restart: on-failure

  hydra:
    container_name: hydra
    image: oryd/hydra:${HYDRA_VERSION}-sqlite
    depends_on:
      - hydra_migrate
    volumes:
      - type: volume
        source: hydra_sqlite
        target: /var/lib/sqlite
        read_only: false
    ports:
      - "${HYDRA_HTTPS_PUBLIC_PORT}:${HYDRA_HTTPS_PUBLIC_PORT}" # Public port
      - "${HYDRA_HTTPS_ADMIN_PORT}:${HYDRA_HTTPS_ADMIN_PORT}" # Admin port
    command: serve all
    restart: on-failure
    secrets:
      - source: ca
        target: /etc/ssl/certs/ca.crt
      - source: hydra.cert
        target: /hydra/ssl/tls.crt
      - source: hydra.key
        target: /hydra/ssl/tls.key
    environment:
      - LOG_LEAK_SENSITIVE_VALUES=true
      - OAUTH2_EXCLUDE_NOT_BEFORE_CLAIM=true
      - SERVE_PUBLIC_PORT=${HYDRA_HTTPS_PUBLIC_PORT}
      - SERVE_PUBLIC_TLS_CERT_PATH=/hydra/ssl/tls.crt
      - SERVE_PUBLIC_TLS_KEY_PATH=/hydra/ssl/tls.key
      - SERVE_ADMIN_PORT=${HYDRA_HTTPS_ADMIN_PORT}
      - SERVE_ADMIN_TLS_ENABLED=true
      - SERVE_ADMIN_TLS_CERT_PATH=/hydra/ssl/tls.crt
      - SERVE_ADMIN_TLS_KEY_PATH=/hydra/ssl/tls.key
      - URLS_SELF_ISSUER=${HYDRA_ISSUER}
      - URLS_SELF_PUBLIC=https://127.0.0.1:${HYDRA_HTTPS_PUBLIC_PORT}
      - URLS_CONSENT=https://127.0.0.1:3000/auth/hydra/consent
      - URLS_LOGIN=https://127.0.0.1:3000/auth/hydra/login
      - URLS_LOGOUT=https://127.0.0.1:3000/logout
      - SECRETS_SYSTEM=iloveinstilliloveinstilliloveinstill
      - OIDC_SUBJECT_IDENTIFIERS_SUPPORTED_TYPES=public
      - DSN=sqlite:///var/lib/sqlite/db.sqlite?_fk=true&mode=rwc
      - STRATEGIES_ACCESS_TOKEN=jwt
      - WEBFINGER_OIDC_DISCOVERY_CLIENT_REGISTRATION_URL=https://api.instill.tech/clients
      - OAUTH2_ALLOWED_TOP_LEVEL_CLAIMS=username

  kratos_migrate:
    container_name: kratos-migrate
    image: oryd/kratos:${KRATOS_VERSION}-sqlite
    environment:
      - DSN=sqlite:///var/lib/sqlite/db.sqlite?_fk=true&mode=rwc
    volumes:
      - type: volume
        source: kratos_sqlite
        target: /var/lib/sqlite
        read_only: false
      - type: bind
        source: ./kratos
        target: /etc/config/kratos
    command: migrate sql -e --yes
    restart: on-failure

  kratos:
    container_name: kratos
    image: oryd/kratos:${KRATOS_VERSION}-sqlite
    depends_on:
      - kratos_migrate
    volumes:
      - type: volume
        source: kratos_sqlite
        target: /var/lib/sqlite
        read_only: false
      - type: bind
        source: ./kratos
        target: /etc/config/kratos
    ports:
      - "${KRATOS_HTTPS_PUBLIC_PORT}:${KRATOS_HTTPS_PUBLIC_PORT}" # Public port
      - "${KRATOS_HTTPS_ADMIN_PORT}:${KRATOS_HTTPS_ADMIN_PORT}" # Admin port
    command: serve --dev
    restart: unless-stopped
    secrets:
      - source: ca
        target: /etc/ssl/certs/ca.crt
      - source: kratos.cert
        target: /kratos/ssl/tls.crt
      - source: kratos.key
        target: /kratos/ssl/tls.key
    environment:
      - LOG_LEAK_SENSITIVE_VALUES=true
      - IDENTITY_DEFAULT_SCHEMA_URL=file:///etc/config/kratos/identity.schema.json
      - SELFSERVICE_DEFAULT_BROWSER_RETURN_URL=https//127.0.0.1:3000
      - SELFSERVICE_METHODS_PASSWORD_ENABLED=true
      - COURIER_SMTP_CONNECTION_URI=smtps://foo:bar@my-mailserver:1234/?skip_ssl_verify=false
      - SERVE_PUBLIC_TLS_CERT_PATH=/kratos/ssl/tls.crt
      - SERVE_PUBLIC_TLS_KEY_PATH=/kratos/ssl/tls.key
      - SERVE_ADMIN_TLS_CERT_PATH=/kratos/ssl/tls.crt
      - SERVE_ADMIN_TLS_KEY_PATH=/kratos/ssl/tls.key
      - SERVE_PUBLIC_BASE_URL=https://127.0.0.1:${KRATOS_HTTPS_PUBLIC_PORT}
      - SERVE_PUBLIC_PORT=${KRATOS_HTTPS_PUBLIC_PORT}
      - SERVE_ADMIN_BASE_URL=https://kratos:${KRATOS_HTTPS_ADMIN_PORT}
      - SERVE_ADMIN_PORT=${KRATOS_HTTPS_ADMIN_PORT}
      - SECRETS_COOKIE:iloveinstilliloveinstilliloveinstill
      - SECRETS_CIPHER:iloveinstilliloveinstilliloveinstill
      - SECRETS_DEFAULT:iloveinstilliloveinstilliloveinstill
      - DSN=sqlite:///var/lib/sqlite/db.sqlite?_fk=true&mode=rwc

  pg_sql:
    container_name: pg-sql
    image: bitnami/postgresql:14.1.0
    restart: unless-stopped
    ports:
      - ${PG_SQL_PORT}:${PG_SQL_PORT}
    environment:
      POSTGRES_PASSWORD: "${PG_SQL_PASSWORD}"
    volumes:
      - pg_sql_data:/bitnami/postgresql
      - ${PG_SQL_SCRIPTS}:/scripts
    healthcheck:
      test: ["CMD", "/scripts/pg_healthcheck.sh"]
      interval: 15s
      timeout: 5s
      retries: 6

  cassandra:
    container_name: cassandra
    image: cassandra:3.11.11
    restart: unless-stopped
    ports:
      - 9042:9042

  temporal:
    container_name: ${TEMPORAL_HOST}
    image: temporalio/auto-setup:${TEMPORAL_VERSION}
    restart: unless-stopped
    environment:
      DB: postgresql
      DB_PORT: ${PG_SQL_PORT}
      POSTGRES_USER: postgres
      POSTGRES_PWD: password
      POSTGRES_SEEDS: ${PG_SQL_HOST}
      DYNAMIC_CONFIG_FILE_PATH: config/dynamicconfig/docker.yaml
    ports:
      - ${TEMPORAL_PORT}:7233
    healthcheck:
      test: ["CMD", "tctl", "--address", "temporal:7233", "workflow", "list"]
      interval: 10s
      timeout: 1m
      retries: 10
    depends_on:
      pg_sql:
        condition: service_healthy

  temporal_admin_tools:
    container_name: ${TEMPORAL_HOST}-admin-tools
    image: temporalio/admin-tools:${TEMPORAL_VERSION}
    restart: unless-stopped
    environment:
      TEMPORAL_CLI_ADDRESS: ${TEMPORAL_HOST}:${TEMPORAL_PORT}
    stdin_open: true
    tty: true
    depends_on:
      - temporal

  temporal_ui:
    container_name: ${TEMPORAL_UI_HOST}
    image: temporalio/ui:${TEMPORAL_UI_VERSION}
    restart: unless-stopped
    environment:
      TEMPORAL_ADDRESS: ${TEMPORAL_HOST}:${TEMPORAL_PORT}
    ports:
      - ${TEMPORAL_UI_PORT}:8080
    depends_on:
      - temporal

  redis:
    container_name: ${REDIS_HOST}
    image: ${REDIS_IMAGE_TAG}
    restart: unless-stopped
    environment:
      ALLOW_EMPTY_PASSWORD: "true"
    ports:
      - ${REDIS_PORT}:6379

  triton_conda_env:
    container_name: triton-conda-env
    image: ${TRITONCONDAENV_IMAGE_TAG}
    volumes:
      - conda_pack:/conda-pack

  triton_server:
    container_name: ${TRITON_SERVER_HOST}
    image: ${TRITONSERVER_IMAGE_TAG}
    restart: unless-stopped
    environment:
      NVIDIA_VISIBLE_DEVICES: 0
    command: tritonserver --model-store=/model-repository --model-control-mode=explicit --allow-http=true --strict-model-config=false --log-verbose=1
    ports:
      - ${TRITON_SERVER_PORT}:8001
      - 8002:8002
      - 8003:8003
    volumes:
      - model_repository:/model-repository
      - conda_pack:/conda-pack
    healthcheck:
      test: ["CMD-SHELL", "curl localhost:8000/v2/health/ready"]
      timeout: 20s
      retries: 10
    shm_size: 2gb
    ulimits:
      memlock: -1
      stack: 67108864
    depends_on:
      - triton_conda_env

volumes:
  hydra_sqlite:
  kratos_sqlite:
  pg_sql_data:
  vdp:
    name: vdp
  airbyte:
    name: airbyte
  conda_pack:
    name: conda-pack
  model_repository:
    name: model-repository